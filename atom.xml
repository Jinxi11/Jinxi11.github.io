<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jinxi11.github.io</id>
    <title>锦夕</title>
    <updated>2020-04-08T13:17:04.773Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jinxi11.github.io"/>
    <link rel="self" href="https://jinxi11.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jinxi11.github.io/images/avatar.png</logo>
    <icon>https://jinxi11.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 锦夕</rights>
    <entry>
        <title type="html"><![CDATA[测试]]></title>
        <id>https://jinxi11.github.io/post/ce-shi/</id>
        <link href="https://jinxi11.github.io/post/ce-shi/">
        </link>
        <updated>2020-04-08T07:19:22.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="一-mysql">一、MySql</h1>
<h2 id="11分组聚合">1.1分组聚合</h2>
<h3 id="111sql语句">1.1.1SQL语句</h3>
<pre><code class="language-mysql">SELECT
	num,
  GROUP_CONCAT(t.winner_phone) phones
FROM
	(
		SELECT
			count(*) AS num,
			a.WINNER_PHONE
		FROM
			hsh_arithmetic_game_result_201909 a
		GROUP BY
			a.WINNER_PHONE
		ORDER BY
			num DESC
	) t
GROUP BY num DESC
</code></pre>
<h3 id="112查询结果">1.1.2查询结果</h3>
<figure data-type="image" tabindex="1"><img src="E:%5C%E6%88%91%E7%9A%84%E6%96%87%E6%A1%A3%5CTypora%5Cpicture%5C1568680179365.png" alt="1568680179365" loading="lazy"></figure>
<h2 id="12存储引擎">1.2<a href="https://www.toutiao.com/i6738677379138322956/">存储引擎</a></h2>
<h1 id="二-mybatis">二、Mybatis</h1>
<h2 id="21批量插入">2.1批量插入</h2>
<h2 id="22常见问题"><a href="https://www.toutiao.com/i6716857855841927692/">2.2常见问题</a></h2>
<ol>
<li></li>
</ol>
<h1 id="三-spring">三、Spring</h1>
<h2 id="31配置文件的加载">3.1配置文件的加载</h2>
<h2 id="32bean的创建"><a href="https://www.toutiao.com/i6738275145925788167/">3.2Bean的创建</a></h2>
<p>​		在容器启动快完成时，会把所有的单例bean进行实例化（预先实例化）。好处是可以及早的发现问题，及早的抛出异常，及早解决。</p>
<ol>
<li>从容器中找出所有的bean定义名称</li>
<li>循环遍历所有的bean名称，检查是否符合条件</li>
<li>判断是否为FactoryBeay&lt;?&gt;类型</li>
<li>开始进入总所熟知的getBean(String name)方法</li>
<li>对手工直接注册的单例对象进行检测</li>
<li>对FactoryBean&lt;?&gt;类型的检测</li>
<li>对类型进行转换</li>
<li>准备好显式指定的依赖，如@DependsOn指定的</li>
<li>解析出bean的Class&lt;?&gt;</li>
<li>调用bean后处理器的postProcessBeforeInstantiation方法</li>
</ol>
<h1 id="四-springboot">四、SpringBoot</h1>
<h2 id="41springboot中tomcat的启动原理"><a href="https://www.toutiao.com/i6739120861929800205/">4.1SpringBoot中Tomcat的启动原理</a></h2>
<ul>
<li>
<p>springboot通过main方法启动</p>
<pre><code class="language-java">@SpringBootApplication
public class TomcatdebugApplication {
    public static void main(String[] args) {
        SpringApplication.run(TomcatdebugApplication.class, args);
    }
}
</code></pre>
</li>
<li>
<p>进入run方法</p>
<ul>
<li>SpringBoot启动过程 ：
<ul>
<li>配置属性</li>
<li>获取监听器，发布应用开始启动事件</li>
<li>初始化输入参数</li>
<li>配置环境，输出 banner</li>
<li>创建上下文</li>
<li>预处理上下文</li>
<li>刷新上下文</li>
<li>再刷新上下文</li>
<li>发布应用已经启动事件</li>
<li>发布应用启动完成事件</li>
</ul>
</li>
<li>run源码</li>
</ul>
<pre><code class="language-java">public ConfigurableApplicationContext run(String... args) {
		StopWatch stopWatch = new StopWatch();
		stopWatch.start();
		ConfigurableApplicationContext context = null;
		Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();
    	// 设置系统属性[java.awt.headless]，为true则启用headless模式支持
		configureHeadlessProperty();
    	// 通过SpringFactoriesLoader检索META-INF/spring.factorie
    	// 找到声明的所有SpringApplicationRunListener的实现类并将其实例
    	// 之后再逐个调用其started()方法，广播SpringBoot要开始执行了
		SpringApplicationRunListeners listeners = getRunListeners(args);
    	// 发布应用开始启动事件
		listeners.starting();
		try {
            // 初始化参数
			ApplicationArguments applicationArguments = new DefaultApplicationArguments(
					args);
            // 创建并配置当前SpringBoot应用将要使用的Enviroment 
            // 遍历调用所有的SpringApplicationRunListener的 environmentPrepared()方法，广播Environment准备完毕
			ConfigurableEnvironment environment = prepareEnvironment(listeners,
					applicationArguments);
			configureIgnoreBeanInfo(environment);
            // 打印banner
			Banner printedBanner = printBanner(environment);
            // 创建应用上下文（与Tomcat有关）
			context = createApplicationContext();
            // 通过SpringFactoriesLoader检索META-INF/spring.factories,获取并实 例化异常分析器
			exceptionReporters = getSpringFactoriesInstances(
					SpringBootExceptionReporter.class,
					new Class[] { ConfigurableApplicationContext.class }, context);
            // 为ApplicationContext加载environment，之后逐个执ontextInitializer的initializer 
            // 并调用所有的SpringApplicationRunListener的contextPrepare
            // 之后初始化IOC容器，并调用SpringApplicationRunListenerd()方法 
            // 这里就包括通过@EnableAutoConfiguration导入的各种自动配置
			prepareContext(context, environment, listeners, applicationArguments,
					printedBanner);
            // 刷新上下文（与Tomcat有关）
			refreshContext(context);
            // 再一次刷新上下文，其实是空方法，可能是为了后续扩展
			afterRefresh(context, applicationArguments);
			stopWatch.stop();
			if (this.logStartupInfo) {
				new StartupInfoLogger(this.mainApplicationClass)
						.logStarted(getApplicationLog(), stopWatch);
			}
            // 发布应用已经启动的事件
			listeners.started(context);
            // 遍历搜一个注册的ApplicationRunner和CommandLineRunner，并执行其 run()方法 
            // 我父母可以实现自己的ApplicationRunner或者CommandLineRunner,来对 SpringBoot的启动过程进行扩展
			callRunners(context, applicationArguments);
		}
		catch (Throwable ex) {
			handleRunFailure(context, ex, exceptionReporters, listeners);
			throw new IllegalStateException(ex);
		}
		try {
            // 应用以及启动完成的监听事件
			listeners.running(context);
		}
		catch (Throwable ex) {
			handleRunFailure(context, ex, exceptionReporters, null);
			throw new IllegalStateException(ex);
		}
		return context;
	}
</code></pre>
<ul>
<li>分析 Tomcat 内容只需要关注两个内容即可：
<ul>
<li>上下文是如何创建的：createApplicationContext()
<ul>
<li>根据webApplicationType来判断创建哪种类型的 Servlet
<ul>
<li>Web 类型(SERVLET)</li>
<li>响应式 Web 类型（REACTIVE)</li>
<li>非 Web 类型(default)</li>
</ul>
</li>
</ul>
</li>
<li>上下文是如何刷新的：refreshContext(context)</li>
<li>走进Tomcat内部
<ul>
<li>第一件事就是把 Connnctor (连接器)对象添加到 Tomcat 中</li>
<li>第二件事就是configureEngine（容器）</li>
</ul>
</li>
</ul>
</li>
<li>总结：Tomcat启动是在刷新上下文中。Tomcat的启动主要是初始化两个核心组件，连接器和容器。</li>
</ul>
</li>
</ul>
<h2 id="42配置文件的加载">4.2配置文件的加载</h2>
<h2 id="43bean的创建">4.3Bean的创建</h2>
<h1 id="五-redis">五、Redis</h1>
<h2 id="51redis内存满了怎么办">5.1Redis内存满了怎么办</h2>
<h3 id="511redis占用内存大小">5.1.1Redis占用内存大小</h3>
<ul>
<li>**</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://jinxi11.github.io/post/hello-gridea/</id>
        <link href="https://jinxi11.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>